@page "/"

@using BlazorBootstrap
@using Grpc.Net.Client
@using MemeOfTheYear
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage

@rendermode @(new InteractiveServerRenderMode(prerender: false))

@inject ProtectedLocalStorage ProtectedLocalStore

@if (showQuestion)
{
    <Modal @ref="modal" UseStaticBackdrop="true" CloseOnEscape="false" IsVerticallyCentered="true"
    ShowCloseButton="false" />
}
else
{
    switch (stage?.Type)
    {
        case Stage.Types.Type.Nominate:
            <Uploader SessionId="@sessionId"></Uploader>
            break;
        case Stage.Types.Type.Vote:
            <Voter SessionId="@sessionId"></Voter>
            break;
        case Stage.Types.Type.Result:
            break;
        default:

            break;
    }
}

@code {
    private Modal modal = default!;
    private string sessionId = "";

    private bool showQuestion = true;

    private Stage? stage = null;

    private GrpcChannel channel;
    private VoteService.VoteServiceClient voteClient;
    private ChallengeService.ChallengeServiceClient challengeClient;

    protected override async Task OnInitializedAsync()
    {
        channel = GrpcChannel.ForAddress("http://localhost:5000");
        voteClient = new VoteService.VoteServiceClient(channel);
        challengeClient = new ChallengeService.ChallengeServiceClient(channel);

        var result = await ProtectedLocalStore.GetAsync<string>("id");
        var response = await voteClient.InitAsync(new SessionIdRequest
            {
                MaxLikes = int.MaxValue,
                SessionId = result.Value ?? string.Empty
            });
        sessionId = response.SessionId;
        stage = response.Stage;

        if (!result.Success)
        {
            await ProtectedLocalStore.SetAsync("id", sessionId);
        }

        showQuestion = !response.IsAuthenticated;
        if (showQuestion)
        {
            var challengeResponse = await challengeClient.GetChallengeAsync(new GetChallengeRequest());

            var parameters = new Dictionary<string, object>();
            parameters.Add(nameof(Challenge.QuestionId), challengeResponse.QuestionId);
            parameters.Add(nameof(Challenge.QuestionText), challengeResponse.QuestionText);
            parameters.Add(nameof(Challenge.SessionId), response.SessionId);
            parameters.Add(nameof(Challenge.OnClickCallback), EventCallback.Factory.Create<TodoItem>(this, OnAnswerClick));

            await modal.ShowAsync<Challenge>("Bitte beantworten!", parameters: parameters);
        }
    }

    private async Task OnAnswerClick(TodoItem answer)
    {
        Console.WriteLine($"got item {answer}");

        var response = await challengeClient.AnswerChallengeAsync(new AnswerChallengeRequest
            {
                Answer = answer.Answer,
                QuestionId = answer.QuestionId,
                SessionId = answer.SessionId
            });

        Console.WriteLine($"success? {response.Success}");
        showQuestion = !response.Success;

        if (showQuestion)
        {
            var challengeResponse = await challengeClient.GetChallengeAsync(new GetChallengeRequest());

            var parameters = new Dictionary<string, object>();
            parameters.Add(nameof(Challenge.QuestionId), challengeResponse.QuestionId);
            parameters.Add(nameof(Challenge.QuestionText), challengeResponse.QuestionText);
            parameters.Add(nameof(Challenge.SessionId), answer.SessionId);
            parameters.Add(nameof(Challenge.OnClickCallback), EventCallback.Factory.Create<TodoItem>(this, OnAnswerClick));

            await modal.ShowAsync<Challenge>("Bitte beantworten!", parameters: parameters);
        }
    }
}