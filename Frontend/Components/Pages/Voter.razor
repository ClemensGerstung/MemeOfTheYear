@using BlazorBootstrap
@using Grpc.Core
@using Grpc.Net.Client
@using MemeOfTheYear.Remote

@rendermode InteractiveServer

@inject ILogger<Voter> Logger
@inject IGrpcClientProvider ClientProvider

<div class="voter-root">
    <div class="media-area" @onclick="OnMediaClick">
        @if (isVideo)
        {
            <video class="media-element" src="@imageContent" autoplay muted playsinline loop></video>
        }
        else
        {
            <img class="media-element" src="@imageContent" />
        }
    </div>

    <div class="controls-row">
        <button class="circle-btn dislike" @onclick="OnDislikeClicked" disabled="@isButtonDisabled">
            <span class="btn-icon">✕</span>
            <div class="particle-container">
                @foreach (var p in dislikeParticles)
                {
                    <span key="@p.Id" class="particle dislike" style="@p.Style"></span>
                }
            </div>
        </button>

        <button class="circle-btn skip" @onclick="Skip" disabled="@isButtonDisabled">
            <span class="btn-icon">»</span>
        </button>

        <button class="circle-btn like" @onclick="OnLikeClicked" disabled="@isButtonDisabled">
            <span class="btn-icon">✓</span>
            <div class="particle-container">
                @foreach (var p in likeParticles)
                {
                    <span key="@p.Id" class="particle like" style="@p.Style"></span>
                }
            </div>
        </button>
    </div>
</div>

<style>
    .voter-root {
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:24px;
        padding:16px 8px;
    }

    .media-area {
        width: min(640px, 92vw);
        aspect-ratio: 1 / 1;
        background: #fff;
        border: 6px solid #111;
        display:flex;
        align-items:center;
        justify-content:center;
        position:relative;
        box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        overflow:hidden;
    }

    .media-element {
        width:100%;
        height:100%;
        object-fit:contain;
        display:block;
    }

    .controls-row {
        display:flex;
        gap:24px;
        align-items:center;
        justify-content:center;
        width:100%;
    }

    .circle-btn {
        width:88px;
        height:88px;
        border-radius:50%;
        border:none;
        display:inline-flex;
        align-items:center;
        justify-content:center;
        position:relative;
        cursor:pointer;
        box-shadow:0 6px 14px rgba(0,0,0,0.12);
        transition: transform 140ms ease;
        font-size:34px;
        color:white;
    }

    .circle-btn:active { transform: scale(0.98); }
    .circle-btn:disabled { opacity:0.45; cursor:not-allowed; }

    .circle-btn.dislike { background: #e74c3c; }
    .circle-btn.like { background: #2ecc71; }
    .circle-btn.skip { background: #1e90ff; }

    .btn-icon { font-weight:700; }

    /* particles */
    .particle-container { position:absolute; inset:0; pointer-events:none; overflow:visible; }
    .particle { position:absolute; left:50%; top:50%; width:10px; height:10px; border-radius:50%; opacity:1; transform:translate(-50%,-50%); }
    .particle.like { background: rgba(46,204,113,0.95); }
    .particle.dislike { background: rgba(231,76,60,0.95); }

    @@keyframes particleMove {
        to { transform: translate(var(--tx), var(--ty)) scale(0.2); opacity:0; }
    }

    .particle { animation: particleMove 800ms cubic-bezier(.15,.8,.35,1) forwards; }

    @@media (max-width:600px) {
        .circle-btn { width:72px; height:72px; font-size:28px; }
        .media-area { width: min(92vw, 520px); }
    }
</style>

@code {
    [Parameter] public string SessionId { get; set; } = "";

    [Parameter] public string FirstImage { get; set; } = "";

    [Parameter] public int StageId { get; set; }

    private string imageContent = "https://placehold.co/400";
    private string currentImageId = "";
    private bool isButtonDisabled = false;
    private bool isVideo = false;

    class Particle
    {
        public string Id { get; } = Guid.NewGuid().ToString();
        public string Style { get; set; } = string.Empty;
    }

    private List<Particle> likeParticles = new();
    private List<Particle> dislikeParticles = new();

    // detect if the provided data url is a video
    private void UpdateMediaType()
    {
        if (string.IsNullOrWhiteSpace(imageContent)) { isVideo = false; return; }
        // imageContent is expected like: data:<mime>;base64, <content>
        try
        {
            var start = imageContent.IndexOf(':');
            var semi = imageContent.IndexOf(';');
            if (start >= 0 && semi > start)
            {
                var mime = imageContent.Substring(start + 1, semi - start - 1).ToLowerInvariant();
                isVideo = mime.StartsWith("video/");
            }
            else isVideo = false;
        }
        catch { isVideo = false; }
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        Logger.LogInformation("{} {}", SessionId, FirstImage);

        await SetNewImage(FirstImage);
    }

    private async Task SetNewImage(string imageId)
    {
        if (string.IsNullOrWhiteSpace(imageId))
        {
            isButtonDisabled = true;
            currentImageId = string.Empty;
            imageContent = "imgs/default.jpg";
            return;
        }

        var imageService = ClientProvider.GetClient<ImageService.ImageServiceClient>();
        var imageResponse = await imageService.GetImageAsync(new GetImageRequest {
            ImageId = imageId,
            SessionId = this.SessionId
        });

        var image = imageResponse.Image;


        var imageStreamService = ClientProvider.GetClient<ImageStreamService.ImageStreamServiceClient>();

        var response = imageStreamService.GetImageData(new GetImageDataRequest {
            ImageId = imageId,
            SessionId = this.SessionId
        });

        var data = response.ResponseStream.ReadAllAsync();
        using var ms = new MemoryStream();
        await foreach (var chunk in data) {
            await ms.WriteAsync(chunk.ChunkData.ToByteArray());
        }
        await ms.FlushAsync();
        ms.Seek(0, SeekOrigin.Begin);
        imageContent = $"data:{image.MimeType};base64, {Convert.ToBase64String(ms.ToArray())}";
        @* Logger.LogDebug("Loaded image data for image {}: {}", imageId, imageContent); *@

        UpdateMediaType();
        currentImageId = imageId;
    }

    private async Task SetVoting(Func<VoteService.VoteServiceClient, Task<VoteResponse>> callback)
    {
        var voteService = ClientProvider.GetClient<VoteService.VoteServiceClient>();

        var response = await callback(voteService);
        if (response.Finished)
        {
            isButtonDisabled = true;
            currentImageId = string.Empty;
            imageContent = "imgs/default.jpg";
        }
        else
        {
            await SetNewImage(response.NextImageId);
        }
    }

    private VoteRequest VoteRequest
    {
        get
        {
            return new VoteRequest
                {
                    ImageId = currentImageId,
                    SessionId = this.SessionId,
                    StageId = this.StageId
                };
        }
    }

    private Task Like()
    {
        return SetVoting(async client =>
        {
            var response = await client.LikeAsync(VoteRequest);

            return response;
        });
    }

    private Task Dislike()
    {
        return SetVoting(async client =>
        {
            var response = await client.DislikeAsync(VoteRequest);

            return response;
        });
    }

    private Task Skip()
    {
        return SetVoting(async client =>
        {
            var response = await client.SkipAsync(VoteRequest);

            return response;
        });
    }

    // UI wrappers that trigger particle animations then call the grpc vote methods
    private async Task OnLikeClicked()
    {
        SpawnParticles(likeParticles, 12);
        await Like();
    }

    private async Task OnDislikeClicked()
    {
        SpawnParticles(dislikeParticles, 12);
        await Dislike();
    }

    private void SpawnParticles(List<Particle> list, int count)
    {
        var rand = new Random();
        list.Clear();
        for (int i = 0; i < count; i++)
        {
            // random direction and distance
            var angle = rand.NextDouble() * Math.PI * 2;
            var dist = 40 + rand.NextDouble() * 120; // px
            var tx = Math.Cos(angle) * dist;
            var ty = Math.Sin(angle) * dist;
            var size = 16 + rand.Next(24);
            var p = new Particle { Style = $"--tx:{tx}px; --ty:{ty}px; width:{size}px; height:{size}px;" };
            list.Add(p);
        }

        // schedule cleanup after animation
        _ = Task.Run(async () =>
        {
            await Task.Delay(900);
            list.Clear();
            await InvokeAsync(StateHasChanged);
        });
    }

    private void OnMediaClick()
    {
        // toggle play/pause if video
        // use JS interop only if needed; simple approach: find video element by DOM id is not trivial here.
        // We'll keep this handler empty for now — video is autoplay muted loop by default.
    }
}