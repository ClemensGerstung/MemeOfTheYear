@rendermode InteractiveServer

@using System.Net.Http.Headers
@using System.Text.Json
@using BlazorBootstrap
@using Grpc.Net.Client
@using MemeOfTheYear.Remote
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage

@inject ProtectedLocalStorage ProtectedLocalStore
@inject IHttpClientFactory ClientFactory
@inject ILogger<Uploader> Logger
@inject NavigationManager NavigationManager
@inject IGrpcClientProvider ClientProvider

<div class="container">
    <p>
        <label>
            Du kannst bis zu @MaxAllowedFiles Memes gleichzeitig hochladen:
            <InputFile OnChange="OnInputFileChange" multiple accept=".jpg,.jpeg,.gif,.png,.mp4,.webm,.mov" />
        </label>
    </p>

    @if (uploadErrors.Any())
    {
        <div class="alert alert-danger mt-3">
            @foreach (var error in uploadErrors)
            {
                <div>@error</div>
            }
        </div>
    }

    @foreach (var progress in uploadProgress)
    {
        <div class="row mt-2">
            <div class="col-md-4">@progress.FileName</div>
            <div class="col-md-8">
                <div class="progress">
                    <div class="progress-bar progress-bar-striped @(progress.IsComplete ? "" : "progress-bar-animated")" 
                         role="progressbar" 
                         style="width: @(progress.Percentage)%"
                         aria-valuenow="@progress.Percentage" 
                         aria-valuemin="0" 
                         aria-valuemax="100">
                        @progress.Percentage%
                    </div>
                </div>
            </div>
        </div>
    }

    @foreach (var uploadResult in uploadResults)
    {
        <div class="row row-cols-auto gy-1">
            <div class="col-md-5 col-sm-12">
                <p>@uploadResult.Name</p>
            </div>
            <div class="col-md-7 col-sm-12 p-1">
                @if (uploadResult.IsVideo)
                {
                    <video src="@uploadResult.Content" controls class="rounded img-fluid" style="max-height: 150px;" />
                }
                else
                {
                    <img src="@uploadResult.Content" class="rounded img-fluid" style="max-height: 150px;" />
                }
            </div>
        </div>
    }
</div>

@code {

    [Parameter] public string SessionId { get; set; } = "";

    [Parameter] public int MaxAllowedFiles { get; set; } = 10;

    [Parameter] public int MaxFileSize { get; set; } = 4 * 1024 * 1024;

    private List<UploadedImage> uploadResults = new();
    private List<string> uploadErrors = new();
    private List<FileUploadProgress> uploadProgress = new();
    private bool shouldRender;

    protected override bool ShouldRender() => shouldRender;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        Logger.LogInformation("{}", SessionId);
    }

    private async Task OnInputFileChange(InputFileChangeEventArgs e)
    {
        shouldRender = false;
        var upload = false;
        uploadErrors.Clear();
        uploadProgress.Clear();

        List<File> files = new();
        using var content = new MultipartFormDataContent();

        var imageService = ClientProvider.GetClient<ImageService.ImageServiceClient>();

        foreach (var file in e.GetMultipleFiles(MaxAllowedFiles))
        {
            try
            {
                if (file.Size > MaxFileSize)
                {
                    uploadErrors.Add($"{file.Name}: File size exceeds {MaxFileSize / (1024 * 1024)}MB limit");
                    continue;
                }

                Logger.LogInformation($"Append File {file.Name} with {file.ContentType}");
                
                var progress = new FileUploadProgress { FileName = file.Name };
                uploadProgress.Add(progress);
                
                files.Add(new() { Name = file.Name });

                var stream = new LazyBrowserFileStream(file, MaxFileSize);
                var fileContent = new StreamContent(stream);
                fileContent.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType);
                
                // Set up progress tracking
                var progressContent = new ProgressStreamContent(fileContent, async uploadProgress => {
                    progress.Percentage = (int)((100.0 * uploadProgress.BytesTransferred) / uploadProgress.TotalBytes);
                    await InvokeAsync(StateHasChanged);
                });
                
                content.Add(content: progressContent, name: "\"files\"", fileName: file.Name);
                upload = true;
                shouldRender = true;
                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                Logger.LogWarning("{0} not uploaded (Err: 6): {1}", file.Name, ex.Message);
                uploadErrors.Add($"{file.Name}: {ex.Message}");
            }
        }

        if (upload)
        {
            using var client = ClientFactory.CreateClient();
            client.DefaultRequestHeaders.Add("session", SessionId);
            using var response = await client.PostAsync($"{NavigationManager.BaseUri}Filesave", content);
            Logger.LogInformation("Is success {}", response.IsSuccessStatusCode);

            // Mark all uploads as complete
            foreach (var progress in uploadProgress)
            {
                progress.Percentage = 100;
                progress.IsComplete = true;
            }
            await InvokeAsync(StateHasChanged);

            if (response.IsSuccessStatusCode)
            {
                var options = new JsonSerializerOptions
                    {
                        PropertyNameCaseInsensitive = true,
                    };

                using var responseStream = await response.Content.ReadAsStreamAsync();
                var newUploadResults = await JsonSerializer.DeserializeAsync<IList<UploadResult>>(responseStream, options);
                Logger.LogInformation("{}", newUploadResults);

                if (newUploadResults is not null)
                {
                    uploadResults.Clear();

                    foreach (var result in newUploadResults)
                    {
                        var imageResponse = await imageService.GetImageAsync(new GetImageRequest
                            {
                                ImageId = result.ImageId,
                                SessionId = this.SessionId
                            });
                        uploadResults.Add(new UploadedImage
                            {
                                Name = result.ImageId,
                                Content = imageResponse.ImageContent
                            });
                    }
                }
            }
        }

        shouldRender = true;
    }

    private class File
    {
        public string? Name { get; set; }
    }

    private class UploadedImage
    {
        public string Name { get; set; } = "";
        public string Content { get; set; } = "";
        public bool IsVideo => Content.StartsWith("data:video/");
    }

    private class FileUploadProgress
    {
        public string FileName { get; set; } = "";
        public int Percentage { get; set; }
        public bool IsComplete { get; set; }
    }
}